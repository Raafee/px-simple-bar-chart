<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. ui tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs
    See https://github.com/jreichenberg/grunt-dep-serve#why-do-we-need-this
-->
<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="px-handle.html" />


<!--
Allow the user to select a value or range of values within a specified min and max.

##### Usage

    <px-slider value="50" min="1" max="100"></px-slider>

@element px-slider
@blurb Allow the user to select a value or range of values within a specified min and max.
@homepage index.html
@demo demo.html
-->
<dom-module id="px-slider">
  <link rel="import" type="css" href="css/px-slider.css" />
  <template>
    <div class="flex">
      <input id="inputStart" type="text" class="text-input" value="{{value}}" on-change="handleStartChange"  tabindex="0"/>
      <div id="sliderContainer" class="slider flex__item" on-click="jumpToValue">
        <div id="sliderSelected" class="slider__selected"></div>
        <px-handle id="startHandle" style="visibility:hidden;" handle-track-event-name="handleTrackStart" on-track="handleTrackStart"></px-handle>
        <px-handle id="endHandle" handle-track-event-name="handleTrackEnd" on-track="handleTrackEnd"></px-handle>
      </div>
      <input id="inputEnd" type="text" style="visibility:hidden;" class="text-input" value="{{endValue}}" on-change="handleEndChange" tabindex="0"/>
    </div>
  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-slider',

    ready: function() {
      // Must have min and max values
      // FATAL
      if (!this.min && this.min !== 0) {
        throw "Missing a minimum value (min).";
      } else if (!this.max && this.max !== 0) {
        throw "Missing a maximum value (max)."
      }

      // Do we have a start value and end value?
      if ( (this.startValue || this.startValue === 0) &&
           (this.endValue || this.endValue === 0) ) {

        // If so, this is a range.
        this._setRange(true);
        this.value = this.startValue;

        // Show the start handle and the end input
        this.$.startHandle.style.visibility = 'visible';
        this.$.inputEnd.style.visibility = 'visible';

        // Let's do some extra error checking to protect developers from themselves
        // Not fatal, but probably not intentional.
        if ( this.value > this.endvalue) {
          console.warn("Your starting value can't be greater than your ending value.");
          this.value = this.endValue;
        } else if (this.value % this.step !== 0 ) {
          console.warn("Your value doesn't match your step: the value needs to be evenly divisible by the step attribute.");
        } else if (this.endValue % this.step !== 0 ) {
          console.warn("Your end value doesn't match your step: the end value needs to be evenly divisible by the step attribute.");
        }

        // Cleanup values, just in case
        this.value = this._cleanValue(this.value);
        this.endValue = this._cleanValue(this.endValue);

        // Have to wait for the DOM to finish loading
        // And then refire these
        this.async(function() {
          this._updateHandle(this.$.startHandle, this.value);
          this._updateHandle(this.$.endHandle, this.endValue);
        }, 1);
      } else {

        if (!this.value && this.value !== 0) {
          throw "Oops, I need a starting value. Did you set the 'value' attribute?"
        }
        this.async(function() {
          this._updateHandle(this.$.endHandle, this.value);
        }, 1);
      }
    },

    /**
     * Properties block, expose attribute values to the DOM via 'reflect'
     *
     * @property properties
     * @type Object
     */
    properties: {
      range: {
        type: Boolean,
        value: false,
        readOnly: true
      },
      value: {
        type: Number,
        reflect: true,
        notify: true,
        observer: '_valueChanged'
      },
      startValue: {
        type: Number,
        reflect: true,
        notify: true,
        observer: '_startValueChanged'
      },
      endValue: {
        type: Number,
        reflect: true,
        notify: true,
        observer: '_endValueChanged'
      },
      min: {
        type: Number,
        value: 1,
        reflect: true,
        observer: '_minChanged'
      },
      max: {
        type: Number,
        value: 100,
        reflect: true,
        observer: '_maxChanged'
      },
      step: {
        type: Number,
        value: 1,
        reflect: true,
        observer: '_stepChanged'
      },
      disabled: {
        type: Boolean,
        value: false,
        reflect: true
      }
    },

    /**
     * Watchers (creepy)
     *
     * Not working, though ...
     *
     */
    _valueChanged: function(newValue, oldValue) {
        var slider = this;
        //this is here to ensure that when we get many consecutive jumps, we debounce them, instead of calculating each one.
        if (slider.debounce) {
          slider.debounce(
            'slider_move', function() {
              var clean = this._cleanValue(newValue);

              // If this is a range, don't go higher than the end value
              if (this.range && clean > this.endValue) {
                clean = this.endValue;
              }

              // If it's a range, we update the start handle; otherwise update the end handle
              var handle = (this.range) ? this.$.startHandle : this.$.endHandle;
              this._updateHandle(handle, this.value);

              // For the sake of ranges, we keep start value and value in sync
              this.startValue = clean;
              this.value = clean;
            }, 1);
        }

    },

    _startValueChanged: function(newValue, oldValue) {
      // This is just really here in case a dev changes this value programmatically
      //this.value = newValue; // Should call value watcher for cleanup
    },

    _endValueChanged: function(newValue, oldValue) {
      var clean = this._cleanValue(newValue);

      // If this is a range, don't go below the start value
      if (this.range && clean < this.value) {
        clean = this.value;
      }

      // Update the end handle
      this._updateHandle(this.$.endHandle, clean);

      // Update endValue with the cleaned value
      this.endValue = clean;
    },

    _minChanged: function(newValue, oldValue) {
      // Step not always defined at load?
      if (!this.step) {
        return;
      }

      // Do the values match the step size?
      // Just warn, don't throw an exception
      if (this.min % this.step !== 0) {
        console.warn("WARNING: min value does not match step size.")
        this.min = this.min - (this.min % this.step);
      }

      // Since we are changing the min, let's go ahead and recheck the start value
      this.value = this._cleanValue(this.value);
    },

    _maxChanged: function(newValue, oldValue) {
      // Step not always defined at load?
      if (!this.step) {
        return;
      }

      // Do the values match the step size?
      // Just warn, don't throw an exception
      if (this.max % this.step !== 0) {
        console.warn("WARNING: max value does not match step size.")
        this.max = this.max - (this.max % this.step);
      }

      // Since we are changing the max, let's go ahead and recheck the end value
      if (this.range) {
        this.endValue = this._cleanValue(this.endValue);
      } else {
        this.value = this._cleanValue(this.value);
      }
    },

    _stepChanged: function(newValue, oldValue) {
      // When the step changes, recheck EVERYTHING!
      this.value = this._checkStep(this.value);
      this.min = this._checkStep(this.min);
      this.max = this._checkStep(this.max);
      if (this.range) {
        this.endValue = this._checkStep(this.endValue);
      }
    },

    _cleanValue: function(dirty) {
      var clean = dirty;

      // Account for 'steps'
      clean = this._checkStep(clean);

      // Check against min and max values
      if (clean > this.max) {
        clean = this.max;
      } else if (clean < this.min) {
        clean = this.min;
      }

      return clean;
    },

    _checkStep: function(dirty) {
      // Bad values on start
      if (!dirty && dirty !== 0) {
        return;
      }

      var clean = dirty;

      // Does the value match our step size?
      // Round down by default (we add back later)
      var stepchange = dirty % this.step;
      clean -= stepchange;

      // If we are more than half way to the next step, add the step.
      if (stepchange > (this.step / 2)) {
        clean += this.step;
      }

      // If decimal is involved, deal with floating point precision
      if(clean.toString().indexOf(".") > -1) {
        clean.toFixed(clean.toString().split(".")[1].length);
      }
      return clean;
    },

    _translateValueToPosition: function(myvalue) {
      // add offset so end handle stops at end of tracking
      var cO = 22;
      var cW = this.$.sliderContainer.offsetWidth - cO;

      // What is the ratio of the value to the max?
      var ratio = myvalue / this.max;

      // Multiple by the width of the container
      var position = ratio * cW;

      return position + 'px';
    },

    _translatePositionToValue: function(mypos) {
      // add offset so end handle stops at end of tracking
      var cO = 22;
      var cW = this.$.sliderContainer.offsetWidth - cO;

      // Have we loaded the container?
      if (cW === 0) {
        return;
      }

      // What is the ratio of my position to the container?
      var ratio = mypos / cW;

      // Convert to value; have to account min values other than 0
      var value = ratio * (this.max - this.min);

      return this._cleanValue(value);
    },

    _updateHandle: function(handle, value) {
      // Determine new x position form value
      var newPos = this._translateValueToPosition(value);

      // Set px value of left position
      handle.style.left = newPos;

      // Update the progress bar, too
      this._updateProgressBar();
    },

    /**
     * Update the progress bar based on change in values
     *
     * @method handleChange
     */
    _updateProgressBar: function() {
      // Value is coming up as undefined, for some reason
      // 0 value is ok, though.
      if (!this.value && this.value !== 0) {
        return;
      }

      // Am I a range or a single value?
      var progressValue = (this.range) ? this.endValue - this.value : this.value;
      var progressPosition = (this.range) ? this.value : 0;

      // Set the width and the position (for ranges)
      this.$.sliderSelected.style.width = this._translateValueToPosition(progressValue);
      this.$.sliderSelected.style.left = this._translateValueToPosition(progressPosition);
    },

    /**
     * Where is the mouse in relation to the slider? Keep it in bounds.
     *
     * @method _findPosition
     */
    _findPosition: function(event) {
      // Is this a drag or a click?
      var mX = (event.detail.x) ? event.detail.x : event.clientX;
      // add offset so end handle stops at end of tracking
      var cO = 22;
      var cL = this.$.sliderContainer.getBoundingClientRect().left;
      var cR = this.$.sliderContainer.getBoundingClientRect().right;
      var cW = this.$.sliderContainer.offsetWidth - cO;
      var position = 0;

      // Check to make sure Mouse is on the screen.
      if (isNaN(mX)) {
        mX = 0;
      }

      if (mX > cR) {
        // Is the mouse passed the right of our container?
        // If so, set the position to the width of the container
        position = cW;
      } else if (mX < cL) {
        // Is the mouse passed the left of our container?
        // If so, set the position to zero
        position = 0;
      } else {
        // Otherwise, position is based on the mouseX minus the offset
        position = mX - cL;
      }

      return position;
    },

    /**
     * Handles updating the value when the START handle is moved
     *
     * @method handleTrackStart
     */
    handleTrackStart: function(event) {
      var newPos = this._findPosition(event);

      // Update the value for the new position
      var newValue = this._translatePositionToValue(newPos);

      // We know this is range
      if (newValue > this.endValue) {
        newValue = this.endValue;
      }
      this.value = newValue;
    },

    /**
     * Handles updating the value when the END handle is moved
     *
     * @method handleEndChange
     */
    handleTrackEnd: function(event) {
      var newPos = this._findPosition(event);

      // Update the value based on the new position
      var newValue = this._translatePositionToValue(newPos);
      if (this.range) {
        if (newValue < this.value) {
          newValue = this.value;
        }
        this.endValue = newValue;
      } else {
        this.value = newValue;
      }
    },

    /**
     * Handles updating the value when the START input textbox is changed
     *
     * @method handleStartChange
     */
    handleStartChange: function(event) {
      // Two way data binding not working?
      this.value = this.$.inputStart.value;
    },

    /**
     * Handles updating the value when the END input textbox is changed
     *
     * @method handleEndChange
     */
    handleEndChange: function(event) {
      // Two way data binding not working?
      this.endValue = this.$.inputEnd.value;
    },

    /**
     * When the user clicks on the slider itself, jump to the corresponding value.
     *
     * @method jumpToValue
     */
    jumpToValue: function(event) {
      var slider = this;
      if (slider.debounce) {
        slider.debounce(
          'slider_jump', function() {
            var newPos = this._findPosition(event);
            // Update the value based on the new position
            var newValue = this._translatePositionToValue(newPos);

            if (this.range) {
              // Which handle do you move?
              if (newValue < this.value) {
                // If it's less than the start value, move the left slider
                this.value = newValue;

              } else if (newValue > this.endValue) {
                // If it's greater than the start value, move the right slider
                this.endValue = newValue;
              } else {
                // We are somewhere in the middle - which handle do we move?!
              }
            } else {
              // Move the only handle
              this.value = newValue;
            }
          }, 1
        );
      }
    }
  });
</script>
